{"version":3,"sources":["assets/sounds/ball-incoming.mp3","assets/sounds/ball-outgoing.mp3","assets/sounds/game-over.mp3","components/Instructions.jsx","components/Score.jsx","components/LoseScreen.jsx","components/SPGame.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Instructions","props","className","Score","served","score","scoreSpan","LoseScreen","onClick","replay","SPGame","incomingSound","Audio","incoming","outgoingSound","outgoing","gameOverSound","gameOver","handleKeyDown","event","keyCode","userHitBall","handleMotion","acceleration","x","state","userSwing","setState","rotationRate","alpha","clearTimeout","returnTimer","play","servedBall","returnTimerLength","Math","round","maxCompRet","minCompRet","document","removeEventListener","window","compRetBall","compReactTime","random","setTimeout","watchForUser","addEventListener","lost","replayGame","this","load","Component","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"0FAAAA,EAAOC,QAAU,IAA0B,2C,gBCA3CD,EAAOC,QAAU,IAA0B,2C,gBCA3CD,EAAOC,QAAU,IAA0B,uC,6LCmB5BC,EAhBM,SAACC,GAGpB,OACE,yBAAKC,UAAU,WACb,6CACA,yBAAKA,UAAU,aACb,yBAAKA,UAAU,qCACf,yBAAKA,UAAU,sCACf,yBAAKA,UAAU,wCAEjB,yBAAKA,UAAU,gBATjB,8OCKWC,EAND,SAACF,GAAW,IAChBG,EAAkBH,EAAlBG,OAAQC,EAAUJ,EAAVI,MACVC,EAAY,8BAAOD,GACzB,OAAO,yBAAKH,UAAU,SAASE,EAASE,EAAY,kBAAC,EAAD,QCQvCC,EAZI,SAACN,GAClB,OACE,yBAAKC,UAAU,cACb,yBAAKA,UAAU,yBAAf,cACA,yBAAKA,UAAU,2BAA2BD,EAAMI,OAChD,yBAAKH,UAAU,0BAA0BM,QAASP,EAAMQ,QAAxD,a,gDCqJSC,E,kDAlJb,WAAYT,GAAQ,IAAD,8BACjB,cAAMA,IAgBRU,cAAgB,IAAIC,MAAMC,KAjBP,EAkBnBC,cAAgB,IAAIF,MAAMG,KAlBP,EAmBnBC,cAAgB,IAAIJ,MAAMK,KAnBP,EAsBnBC,cAAgB,SAACC,GAEf,OAAQA,EAAMC,SACZ,KAFgB,GAGd,EAAKC,gBA1BQ,EAiCnBC,aAAe,SAACH,GACVA,EAAMI,aAAaC,EAAI,EAAKC,MAAMC,WACpC,EAAKC,SAAS,CAAED,UAAWP,EAAMI,aAAaC,IAE5CL,EAAMS,aAAaC,OAAS,KAAO,EAAKJ,MAAMC,WAAa,KAC7D,EAAKC,SAAS,CAAED,UAAW,IAC3B,EAAKL,gBAvCU,EAoEnBA,YAAc,WAKZ,GAHAS,aAAa,EAAKC,aAClB,EAAKpB,cAAcqB,OAEf,EAAKP,MAAMQ,YAIb,GAFA,EAAKN,SAAS,CAAEtB,MAAO,EAAKoB,MAAMpB,MAAQ,EAAGqB,UAAW,IAEpD,EAAKD,MAAMpB,MAAQ,KAAO,EAAG,CAC/B,IAAM6B,EAAoBC,KAAKC,MAC7B,EAAKX,MAAMS,kBAAmD,GAA/B,EAAKT,MAAMS,mBAEtCG,EAAaF,KAAKC,MACtB,EAAKX,MAAMY,WAAqC,GAAxB,EAAKZ,MAAMY,YAE/BC,EAAaH,KAAKC,MACtB,EAAKX,MAAMa,WAAqC,GAAxB,EAAKb,MAAMa,YAGrC,EAAKX,SAAS,CAAEO,oBAAmBG,aAAYC,qBAIjD,EAAKX,SAAS,CAAEM,YAAY,IAI9BM,SAASC,oBAAoB,UAAW,EAAKtB,eAC7CuB,OAAOD,oBAAoB,eAAgB,EAAKlB,cAAc,GAG9D,EAAKoB,eApGY,EAwGnBA,YAAc,WAAO,IAAD,EACiB,EAAKjB,MAAhCY,EADU,EACVA,WAAYC,EADF,EACEA,WACdK,EAAgBR,KAAKC,MACzBD,KAAKS,UAAYP,EAAaC,GAAcA,GAI9CO,YAAW,WACT,EAAK/B,cAAckB,OACnB,EAAKc,iBACJH,IAlHc,EAsHnBG,aAAe,WACbP,SAASQ,iBAAiB,UAAW,EAAK7B,eAC1CuB,OAAOM,iBAAiB,eAAgB,EAAKzB,cAAc,GAG3D,EAAKS,YAAcc,YAAW,WAC5B,EAAKlB,SAAS,CAAEqB,MAAM,IACtB,EAAKhC,cAAcgB,OACnBO,SAASC,oBAAoB,UAAW,EAAKtB,eAC7CuB,OAAOD,oBAAoB,eAAgB,EAAKlB,cAAc,KAC7D,EAAKG,MAAMS,oBAhIG,EAmInBe,WAAa,WACXV,SAASQ,iBAAiB,UAAW,EAAK7B,eAC1CuB,OAAOM,iBAAiB,eAAgB,EAAKzB,cAAc,GAC3D,EAAKK,SAAS,CACZtB,MAAO,EACP2C,MAAM,EACNf,YAAY,EACZC,kBAAmB,IACnBG,WAAY,IACZC,WAAY,IACZZ,UAAW,KA3Ib,EAAKD,MAAQ,CACXpB,MAAO,EACP2C,MAAM,EACNf,YAAY,EACZC,kBAAmB,IACnBG,WAAY,IACZC,WAAY,IACZZ,UAAW,GATI,E,gEA6CjBwB,KAAKvC,cAAcwC,OACnBD,KAAKpC,cAAcqC,OACnBD,KAAKlC,cAAcmC,OACnBZ,SAASQ,iBAAiB,UAAWG,KAAKhC,eAC1CuB,OAAOM,iBAAiB,eAAgBG,KAAK5B,cAAc,K,6CAI3DiB,SAASC,oBAAoB,UAAWU,KAAKhC,eAC7CuB,OAAOD,oBAAoB,eAAgBU,KAAK5B,cAAc,K,+BAI9D,OAAO4B,KAAKzB,MAAMuB,KAChB,kBAAC,EAAD,CAAY3C,MAAO6C,KAAKzB,MAAMpB,MAAOI,OAAQyC,KAAKD,aAElD,kBAAC,EAAD,CAAO5C,MAAO6C,KAAKzB,MAAMpB,MAAOD,OAAQ8C,KAAKzB,MAAMQ,iB,GA9DpCmB,aCGNC,MARf,WACE,OACE,yBAAKnD,UAAU,OACb,kBAAC,EAAD,QCIcoD,QACW,cAA7Bb,OAAOc,SAASC,UAEe,UAA7Bf,OAAOc,SAASC,UAEhBf,OAAOc,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFrB,SAASsB,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.13c3266a.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/ball-incoming.09c537af.mp3\";","module.exports = __webpack_public_path__ + \"static/media/ball-outgoing.177649ca.mp3\";","module.exports = __webpack_public_path__ + \"static/media/game-over.f945164c.mp3\";","import React from \"react\";\r\n\r\n// Displays instructions\r\nconst Instructions = (props) => {\r\n  const instructions =\r\n    \"You will need to swing the phone to serve the ball.  You will hear a sound indicating you have hit the ball.  The computer will make a sound indicating it has hit back.  Swing the phone to hit the ball again and increase your score.\";\r\n  return (\r\n    <div className=\"instDiv\">\r\n      <div>Instructions</div>\r\n      <div className=\"linebreak\">\r\n        <div className=\"linebreak_dot linebreak_dot-blue\"></div>\r\n        <div className=\"linebreak_dot linebreak_dot-white\"></div>\r\n        <div className=\"linebreak_dot linebreak_dot-yellow\"></div>\r\n      </div>\r\n      <div className=\"instructions\">{instructions}</div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Instructions;\r\n","import React from \"react\";\r\nimport Instructions from \"./Instructions\";\r\n\r\n// Displays instructions and then the current score\r\nconst Score = (props) => {\r\n  const { served, score } = props;\r\n  const scoreSpan = <span>{score}</span>;\r\n  return <div className=\"score\">{served ? scoreSpan : <Instructions />}</div>;\r\n};\r\n\r\nexport default Score;\r\n","import React from \"react\";\r\n\r\n// Displays Replay Button and input for high score if highest score\r\nconst LoseScreen = (props) => {\r\n  return (\r\n    <div className=\"loseScreen\">\r\n      <div className=\"loseScreen_score-text\">Your Score</div>\r\n      <div className=\"loseScreen_score-number\">{props.score}</div>\r\n      <div className=\"loseScreen_replayButton\" onClick={props.replay}>\r\n        Replay?\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default LoseScreen;\r\n","import React, { Component } from \"react\";\r\n\r\nimport Score from \"./Score\";\r\nimport LoseScreen from \"./LoseScreen\";\r\n// import Temp from \"./Temp\";\r\n\r\nimport incoming from \"../assets/sounds/ball-incoming.mp3\";\r\nimport outgoing from \"../assets/sounds/ball-outgoing.mp3\";\r\nimport gameOver from \"../assets/sounds/game-over.mp3\";\r\n\r\nclass SPGame extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      score: 0,\r\n      lost: false,\r\n      servedBall: false,\r\n      returnTimerLength: 1000,\r\n      maxCompRet: 800,\r\n      minCompRet: 600,\r\n      userSwing: 0,\r\n    };\r\n  }\r\n\r\n  // returnTimer is the setTimeout.  If user hits the ball, the setTimeout is cancelled, otherwise user loses.\r\n  returnTimer;\r\n\r\n  // soundfiles\r\n  incomingSound = new Audio(incoming);\r\n  outgoingSound = new Audio(outgoing);\r\n  gameOverSound = new Audio(gameOver);\r\n\r\n  //  keeping handleKeyDown for testing on the computer purposes\r\n  handleKeyDown = (event) => {\r\n    const SPACE_KEY = 32;\r\n    switch (event.keyCode) {\r\n      case SPACE_KEY:\r\n        this.userHitBall();\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  handleMotion = (event) => {\r\n    if (event.acceleration.x > this.state.userSwing) {\r\n      this.setState({ userSwing: event.acceleration.x });\r\n    }\r\n    if (event.rotationRate.alpha >= 200 && this.state.userSwing >= 15) {\r\n      this.setState({ userSwing: 0 });\r\n      this.userHitBall();\r\n    }\r\n  };\r\n\r\n  componentDidMount() {\r\n    // This addresses a bug where the sound was not playing the first time.\r\n    this.incomingSound.load();\r\n    this.outgoingSound.load();\r\n    this.gameOverSound.load();\r\n    document.addEventListener(\"keydown\", this.handleKeyDown);\r\n    window.addEventListener(\"devicemotion\", this.handleMotion, true);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\r\n    window.removeEventListener(\"devicemotion\", this.handleMotion, true);\r\n  }\r\n\r\n  render() {\r\n    return this.state.lost ? (\r\n      <LoseScreen score={this.state.score} replay={this.replayGame} />\r\n    ) : (\r\n      <Score score={this.state.score} served={this.state.servedBall} />\r\n    );\r\n    // return <Temp />;\r\n  }\r\n\r\n  // If the user hits the ball detemine if it is a serve or a volley\r\n  // If it is a volley increment the points and maybe speed the game up\r\n  userHitBall = () => {\r\n    // If user hits the ball, we want to clear the returnTimer SetTimeout from triggering.\r\n    clearTimeout(this.returnTimer);\r\n    this.incomingSound.play();\r\n\r\n    if (this.state.servedBall) {\r\n      // Increment Score\r\n      this.setState({ score: this.state.score + 1, userSwing: 0 });\r\n      // Every 10 hits quicken the gameplay by 10%\r\n      if (this.state.score % 10 === 0) {\r\n        const returnTimerLength = Math.round(\r\n          this.state.returnTimerLength - this.state.returnTimerLength * 0.1\r\n        );\r\n        const maxCompRet = Math.round(\r\n          this.state.maxCompRet - this.state.maxCompRet * 0.1\r\n        );\r\n        const minCompRet = Math.round(\r\n          this.state.minCompRet - this.state.minCompRet * 0.1\r\n        );\r\n\r\n        this.setState({ returnTimerLength, maxCompRet, minCompRet });\r\n      }\r\n    } else {\r\n      // Ball is now served\r\n      this.setState({ servedBall: true });\r\n    }\r\n\r\n    // Disable user\r\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\r\n    window.removeEventListener(\"devicemotion\", this.handleMotion, true);\r\n\r\n    // Sends ball to computer\r\n    this.compRetBall();\r\n  };\r\n\r\n  // Computer will wait a random number within a range before allowing sending ball back\r\n  compRetBall = () => {\r\n    const { maxCompRet, minCompRet } = this.state;\r\n    const compReactTime = Math.round(\r\n      Math.random() * (maxCompRet - minCompRet) + minCompRet\r\n    );\r\n\r\n    // At the end of the timeout the computer hits the ball back to the user\r\n    setTimeout(() => {\r\n      this.outgoingSound.play();\r\n      this.watchForUser();\r\n    }, compReactTime);\r\n  };\r\n\r\n  // Allows User to hit the ball again within alloted time.\r\n  watchForUser = () => {\r\n    document.addEventListener(\"keydown\", this.handleKeyDown);\r\n    window.addEventListener(\"devicemotion\", this.handleMotion, true);\r\n\r\n    //  If this is not cancelled by userHitBall, the user is a loser.\r\n    this.returnTimer = setTimeout(() => {\r\n      this.setState({ lost: true });\r\n      this.gameOverSound.play();\r\n      document.removeEventListener(\"keydown\", this.handleKeyDown);\r\n      window.removeEventListener(\"devicemotion\", this.handleMotion, true);\r\n    }, this.state.returnTimerLength);\r\n  };\r\n\r\n  replayGame = () => {\r\n    document.addEventListener(\"keydown\", this.handleKeyDown);\r\n    window.addEventListener(\"devicemotion\", this.handleMotion, true);\r\n    this.setState({\r\n      score: 0,\r\n      lost: false,\r\n      servedBall: false,\r\n      returnTimerLength: 1000,\r\n      maxCompRet: 800,\r\n      minCompRet: 600,\r\n      userSwing: 0,\r\n    });\r\n  };\r\n}\r\n\r\nexport default SPGame;\r\n","import React from 'react';\r\n\r\nimport './App.css';\r\nimport SPGame from './components/SPGame';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className='App'>\r\n      <SPGame />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}